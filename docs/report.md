# Arch-2025-Lab3 实验报告

## 跳转指令与更多的运算类型

### 23307130064 周弈成

## 内容简介

在根据五级流水线框架构成的、实现了基本运算和访存指令的流水线CPU的基础上，构建支持移位与置位运算和分支跳转指令的流水线架构CPU。实现的指令有：

* 运算指令：sll(i)(w), srl(i)(w), sra(i)(w), slt(i)(u)
* 长立即数指令：auipc
* 分支与跳转指令：beq, bne, blt(u), bge(u), jal, jalr

## 实验结果

能够通过lab3的所有测试，显示“HIT GOOD TRAP”。

* 测试结果![lab3结果](result.png)
* 彩蛋：鸣谢交学长![TanYifan](yifan.png)

## 文件结构变化

`/pipeline`文件夹内文件结构有变化：

* 将`/decode/`中与`/fetch/decoder.sv`有关的模块迁移到`/fetch/`中；
* `/fetch/shamtzeroext.sv`：新增扩展模块，为移位运算指令零扩展移位立即数，统一格式；
* `/execute/branch.sv`：新增分支判断模块，判断是否满足跳转条件，实现与alu相似；
* `/fetch/pcselect.sv`不再使用。

此外，修改下列文件：

* `/src/core.sv`：
  * 更改pc类型，统一为word_t；
  * 修正寄存器接口名称；
  * 增添分支跳转用阻塞；
  * 修复load-use阻塞；
  * 按格式修正提交内容。
* `/include/pipes.sv`：增添新增指令类型解码值，在控制信号中增加分支判断函数类型与跳转专用信号；
* `/pipeline/fetch/fetch.sv`：更改添加气泡的功能实现，增添气泡接口；
* `/pipeline/fetch/decoder.sv`：增添新增解码情况与立即数种类；
* `/pipeline/decode/decode.sv`：更改添加气泡的功能实现，增添气泡接口；
* `/pipeline/execute/execute.sv`：
  * 增添调用分支判断的模块；
  * 增添是否分支与分支目标的输出接口。
* `/pipeline/execute/alu.sv`：修正了增添的部分其他运算，并启用；
* `/pipeline/memory/memory.sv`：修正写寄存器值条件，仅regwrite为真时写入值；
* `/pipeline/writeback/writeback.sv`：简化逻辑。

## 移位及置位运算设计细节

由于移位与置位运算中，w指令与一般指令差别较大，分别设计alu函数。
需要截取相应位数并进行相应运算。
运算时，需要特别标注是否为有符号数，采用systemverilog提供的`$signed()`和`$unsigned()`函数实现。

## 访存流程

实现转发后，需要为新指令实现访存流程。需要根据指令表，设计相应解码值和控制信号，设计memory模块的访存流程，并实现访存期间的流程阻塞。

memory模块需要实现发起访存请求dreq和接收访存结果dresp的功能。其中，为避免重复发送访存请求，需要在接收到结果后清除当前访存请求，所以采用时序逻辑；接收访存结果的功能用组合逻辑实现。

访存请求由使能、地址、大小、写入数据、写入掩码模式组成；访存结果由两个使能和读取数据组成。由于访存地址对齐到`0x8`，且访存指令要求字节数多样，访存请求的后两者和访存结果的读取数据需要特殊处理：

* 首先处理访存地址对齐前的偏移量，保存为地址偏移量；
* 地址偏移量零扩展为64位后，乘8（左移3位），保存为字节偏移量；
* 根据字节偏移量，左移写入数据的相应位数；
* 根据指令要求，确定写入掩码位数，并左移地址偏移量；
* 接收访存请求后，先需要把得到的数据右移字节偏移量位，再根据指令类型做两种位扩展选其一，存入流水线寄存器。

访存请求过程中，需要阻塞流水线除写回外的阶段，到访存请求完成时，则需要强制刷新其他阶段。为此，设置专用阻塞逻辑：

* 当访存请求存在且访存结果未返回时，阻塞；
* 由于访存阻塞的时序逻辑延迟，需要在接收需要访存的控制信号（写内存或读内存）时立即开始阻塞；
* 当阻塞完成时，强制刷新，在core中采用时序逻辑记录上次访存阻塞结果并判断与此次不同来代表强制刷新。

正确处理访存请求后，可以通过部分lab2的测试，检查完其他部分后，可以完全通过。

## load-use阻塞

上句指令为写内存指令时，若下句使用到了此句的寄存器目的地址作为数据源，因为在下句执行过程前上句的访存过程未完成，无法通过转发方式传递数据，需要添加bubble阻塞。

为此，在取指阶段和译码阶段增加相应判断，以阻塞取指阶段来添加bubble空指令。

添加bubble通过把此次取指到的指令和控制信号改为空值实现。这类全空指令不提交至difftest。

实现阻塞后，可以通过lab2的大部分测试，检查完其他部分后，可以完全通过。

## 实验过程

本次实验耗时较长，过程曲折。

先完成了转发部分框架，但是此时观察波形图，发现各个指令间有一个周期的气泡，把dataM转发改为dataW转发后通过了lab1，未注意此处存在结构性问题。

结果在构建访存部分阻塞时，由于执行阶段此时未完成，无法通过常规方式保持各阶段同步进行，CPU死机。

* 抓狂的本人试图在未解决问题时手绘波形图解决阻塞问题![抓狂的本人试图在未解决问题时手绘波形图解决阻塞问题](stalldraft.jpg)

排查原因，发现是未接收请求指令结果时没有阻塞流水线，导致实际执行单位为半周期（一个clk上升沿）；实际上，为保持每周期同步执行，各阶段应各延迟半个周期，由pc阻塞信号控制。

* 某位热心同学在助教基础上给出的理想波形图![某位热心同学在助教基础上给出的理想波形图](stallrealm.jpg)

实现后，可以同步进行各阶段，且可以正常实现访存阻塞，波形图符合预期。然后实现load-use阻塞。

实现后，发现有较靠后的读内存指令出错。排除了地址与流水线相关故障后，猜测是先前对同一地址写入的内存数据有误。发现先前编写的转发模块对于即将写入内存的寄存器值未生效，修改后，可以通过。
